"""
443. 压缩字符串
给定一组字符，使用原地算法将其压缩。压缩后的长度必须始终小于或等于原数组长度。
数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。
在完成原地修改输入数组后，返回数组的新长度。

进阶：
你能否仅使用O(1) 空间解决问题？

示例 1：
输入：
["a","a","b","b","c","c","c"]
输出：
返回6，输入数组的前6个字符应该是：["a","2","b","2","c","3"]

说明：
"aa"被"a2"替代。"bb"被"b2"替代。"ccc"被"c3"替代。

示例 2：
输入：
["a"]
输出：
返回1，输入数组的前1个字符应该是：["a"]

说明：
没有任何字符串被替代。

示例 3：
输入：
["a","b","b","b","b","b","b","b","b","b","b","b","b"]
输出：
返回4，输入数组的前4个字符应该是：["a","b","1","2"]。

说明：
由于字符"a"不重复，所以不会被压缩。"bbbbbbbbbbbb"被“b12”替代。
注意每个数字在数组中都有它自己的位置。

注意：
所有字符都有一个ASCII值在[35, 126]区间内。
1 <= len(chars) <= 1000。
"""


class Solution(object):
    def compress(self, chars):
        """
        :type chars: List[str]
        :rtype: int
        """
        cl = len(chars)
        i, j, cur = 0, 0, 0
        while (i < cl):
            while (j < cl and chars[i] == chars[j]):
                j = j + 1
            chars[cur] = chars[i]
            cur = cur + 1
            if (j - i > 1):
                for c in str(j - i):
                    chars[cur] = c
                    cur = cur + 1
            i = j

        return cur


s = Solution()
print(s.compress(["a", "a", "b", "b", "c", "c", "c", "d", "e"]))

print(
    s.compress(
        ["a", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b",
         "c"]))
"""
此题解法：由于无法使用更多的空间来对字符串内容进行计数，所以就只能使用双指针的方法。
* 一个指针的指向重复字符串的第一个，另一个指针的向后遍历并计数。就可以得到这个重复串的个数。
* 由于还需要在原数组上进行修改，那就还需要一个指针cur来标记下一个可以修改的位置。
* 最终cur的值就是修改完成以后数组的长度。
"""
