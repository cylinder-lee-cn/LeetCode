"""
393. UTF-8 编码验证

UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：

对于 1 字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。
对于 n 字节的字符 (n > 1)，第一个字节的前 n 位都设为1，第 n+1 位设为0，
后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
这是 UTF-8 编码的工作方式：

   Char. number range  |        UTF-8 octet sequence
      (hexadecimal)    |              (binary)
   --------------------+---------------------------------------------
   0000 0000-0000 007F | 0xxxxxxx
   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。

注意:
输入是整数数组。只有每个整数的最低 8 个有效位用来存储数据。这意味着每个整数只表示 1 字节的数据。

示例 1:
data = [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.
返回 true 。
这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。

示例 2:
data = [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.
返回 false 。
前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。
下一个字节是开头为 10 的延续字节，这是正确的。
但第二个延续字节不以 10 开头，所以是不符合规则的。
"""


class Solution:
    def validUtf8(self, data):
        """
        :type data: List[int]
        :rtype: bool
        """
        count = 0  # 2-4位编码，count取值位1，2，3
        for d in data:
            if (128 <= d <= 191):  # 如果是10开头的，就要判断count是否为0，如果是0，不符合要求
                if (count == 0):
                    return False
                count = count - 1  # 如果count>0 那么从count除去1
            else:  # 如果数字不是10开头的，那么count就应该是0
                if (count != 0):
                    return False
                if (0 <= d <= 127):
                    continue
                elif (192 <= d <= 223):
                    count = 1
                elif (224 <= d <= 239):
                    count = 2
                elif (240 <= d <= 247):
                    count = 3
                else:  # 如果比247大，或者比0小，非法
                    return False
        return count == 0


s = Solution()
# s.validUtf8([197, 130, 1])
print(
    s.validUtf8([
        228, 133, 160, 226, 137, 188, 240, 136, 178, 191, 216, 169, 231, 172,
        169, 6, 206, 154, 224, 181, 164, 244, 172, 133, 158, 224, 153, 171,
        245, 148, 174, 141, 239, 141, 130, 220, 153, 245, 163, 158, 164, 230,
        174, 179, 12, 224, 171, 160, 240, 162, 135, 147, 192, 145, 230, 181,
        167, 30, 196, 140, 226, 128, 136, 46, 213, 190, 232, 133, 183, 240,
        166, 191, 177, 38, 235, 147, 142, 234, 128, 167, 245, 150, 134, 139,
        217, 161, 233, 135, 129, 246, 167, 145, 140, 228, 183, 191, 241, 153,
        173, 152, 46, 206, 130, 244, 134, 179, 149, 235, 146, 144
    ]))
"""
此题解法：
* 遍历data，将int转换成bin的字符串，过滤掉'0b'，然后补到8位。
* 用'0'将utfcode切成三段，计算第一段的‘1’，如果是0，那么就是1位的编码
* 如果是1或>=5，错误，必须是2-4.
* 如果是2-4，利用循环取后面1-3个，同时判断一下是否到了边界，后面1-3个都必须是‘10’开头
        i = 0
        d_l = len(data)

        while (i < d_l):
            utfcode = bin(data[i]).replace('0b', '').zfill(8)
            n = utfcode.partition('0')[0].count('1')
            if (n == 0):
                i = i + 1
            elif (n == 1 or n >= 5):
                return False
            else:
                for j in range(1, n):
                    if (i + j >= d_l):
                        return False
                    tmpcode = bin(data[i + j]).replace('0b', '').zfill(8)
                    if (tmpcode[:2] == '10'):
                        continue
                    else:
                        return False
                i = i + j + 1
            # print(i)
        return True
-----------------------分割线----------------------
utf-8的编码：
* 1位的是0开头，  最小是'0b00000000'=0,  最大是'0b01111111'=127

* 2位的是110开头，最小是'0b11000000'=192,最大是'0b11011111'=223
* 3位的是1110开头，最小是'0b11100000'=224,最大是'0b11101111'=239
* 4位的是11110开头，最小是'0b11110000'=240,最大是'0b11110111'=247
* 10开头的，最小是'0b10000000'=128，最大是'0b10111111'=191

按照题中编码规律，那么：
如果数字在[192，223]之间，那么后面要跟1个[128，191]的数字
如果数字在[224，239]之间，那么后面要跟2个[128，191]的数字
如果数字在[240，247]之间，那么后面要跟3个[128，191]的数字
[0-127]之间的数字合法，大于247的数字非法。
"""
