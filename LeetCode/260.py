"""
260. 只出现一次的数字 III

给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

示例 :
输入: [1,2,1,3,2,5]
输出: [3,5]

注意：
结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。
你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
"""


class Solution:
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        xo = 0
        for n in nums:
            xo = xo ^ n

        xo = xo & (-xo)

        result = [0, 0]

        for n in nums:
            if (n & xo == 0):
                result[0] = result[0] ^ n
            else:
                result[1] = result[1] ^ n
        return result


s = Solution()
print(s.singleNumber([1, 2, 1, 3, 2, 5]))
"""
此题解法：
* 源自网上

在这组数中，有两个数都只出现了一次，其他的都出现了两次。可以看到这样一种巧妙的处理思路。先全部xor一遍，
获得这两个数xor的结果。然后找到这个结果中从右往左数第一个1，说明这两个数字这一位不相同。
然后依据这个性质，把所有的数分成两组。

这两个只出现过一次的数一定在不同组，而同一个数出现两次都会在同一个组。所以对这两组分别进行之前的处理，
就会获得这两个数字。至于怎么获得一个数最右一个1，
作者用了diff &= -diff。解释一下，一个数变成负的，2's complement的情况就是取反加一。
对于最后连续的0，取反后会变成连续的1，这时候再加一又会变成连续的0，但是拥有了1的进位。
所以对连续的0和连续的1进行and处理，得到的还是连续的0。直到碰到一个原来的1，取反后是0，拥有了1的进位，也会变成1，
所以1和1 and会得到1.而在这左边的1和0在取反之后都不会再被进位所影响，所以and之后的结果也一定是0.
因此这个方法可以得到最右的一个1，其他都是0.
"""
