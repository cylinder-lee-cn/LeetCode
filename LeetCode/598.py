"""
598. 范围求和 II

给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。

操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，
含义是将所有符合 0 <= i < a 以及 0 <= j < b 的元素 M[i][j] 的值都增加 1。

在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。

示例 1:
输入:
m = 3, n = 3
operations = [[2,2],[3,3]]
输出: 4
解释:
初始状态, M =
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]

执行完操作 [2,2] 后, M =
[[1, 1, 0],
 [1, 1, 0],
 [0, 0, 0]]

执行完操作 [3,3] 后, M =
[[2, 2, 1],
 [2, 2, 1],
 [1, 1, 1]]

M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。
注意:

m 和 n 的范围是 [1,40000]。
a 的范围是 [1,m]，b 的范围是 [1,n]。
操作数目不超过 10000。
"""


class Solution:
    def maxCount(self, m, n, ops):
        """
        :type m: int
        :type n: int
        :type ops: List[List[int]]
        :rtype: int
        """
        times = len(ops)
        if (len(ops) == 0):
            return (m * n)

        a = min([ops[x][0] for x in range(times)])
        # a=min(op[0] for op in ops)
        b = min([ops[x][1] for x in range(times)])
        # b=min(op[1] for op in ops)
        return (a * b)


s = Solution()
print(s.maxCount(3, 3, [[2, 2], [3, 3]]))
print(s.maxCount(3, 3, []))
print(s.maxCount(18, 3,
      [[16, 1], [14, 3], [14, 2], [4, 1], [10, 1], [11, 1], [8, 3], [16, 2],
       [13, 1], [8, 3], [2, 2], [9, 1], [3, 1], [2, 2], [6, 3]]))


"""
此题解法：
* 相当于一个m*n的方格纸，格子里都是0，每次都给x in (0,a-1) , y in (0,b-1)的格子 +1
* 都是从0,0开始的，也就是要找到覆盖次数最多的格子。也就是从ops中找到x和y的最小值。
    然后返回x×y 
* 如果ops是[]，就是没有操作，全都是0，必须返回m×n
"""
