"""
762. 二进制表示中质数个计算置位

给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。
（注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。）

示例 1:
输入: L = 6, R = 10
输出: 4
解释:
6 -> 110 (2 个计算置位，2 是质数)
7 -> 111 (3 个计算置位，3 是质数)
9 -> 1001 (2 个计算置位，2 是质数)
10-> 1010 (2 个计算置位，2 是质数)

示例 2:
输入: L = 10, R = 15
输出: 5
解释:
10 -> 1010 (2 个计算置位, 2 是质数)
11 -> 1011 (3 个计算置位, 3 是质数)
12 -> 1100 (2 个计算置位, 2 是质数)
13 -> 1101 (3 个计算置位, 3 是质数)
14 -> 1110 (3 个计算置位, 3 是质数)
15 -> 1111 (4 个计算置位, 4 不是质数)

注意:
L, R 是 L <= R 且在 [1, 10^6] 中的整数。
R - L 的最大值为 10000。
"""


class Solution:
    def countPrimeSetBits(self, L, R):
        """
        :type L: int
        :type R: int
        :rtype: int
        """

        def is_prime(n):
            if (n <= 1):
                return False
            if (n % 2 == 0):
                return (n == 2)
            if (n % 3 == 0):
                return (n == 3)
            if (n % 5 == 0):
                return (n == 5)
            for p in range(7, (int(n**0.5) + 1), 2):  # 只考虑奇数为因子的情况
                print(p)
                if (n % p == 0):
                    return False
            return True

        count = 0

        for i in range(L, R + 1):
            if (is_prime(bin(i).count('1'))):
                count = count + 1

        return count


s = Solution()
print(s.countPrimeSetBits(6, 10))
print(s.countPrimeSetBits(10, 15))
"""
此题解法：将整数转换成二进制，然后统计1的个数，再判断这个个数是否是质数，如果是的话就+1
* 此题技巧，R<=10^6 (1000000)，转换成二进制0b11110100001001000000，也就是20位长。
  那么最多有20个1，也就是要找（1-20）内有哪些质数
* (2,3,5,7,11,13,17,19)就是所有<=20的质数，只要在这里判断即可。
* 可以构造一个长度21的List来对应0-20是否是质数
* prime=[0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]

    count=0
    prime=[0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]
    for i in range(L,R+1):
        count=count+prime[bin(i).count('1')]
    return count
"""
